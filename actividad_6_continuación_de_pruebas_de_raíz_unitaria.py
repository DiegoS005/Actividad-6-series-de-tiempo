# -*- coding: utf-8 -*-
"""Actividad 6 - Continuación de Pruebas de raíz unitaria.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oNfKCF0KziUUt7YjNV2kMwKVeB_qxaA9
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller, coint
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import warnings
warnings.filterwarnings("ignore")

# Define stocks and date range
tickers = ['AMZN', 'GOOGL', 'JPM', 'NVDA']
start_date = '2019-11-29'
end_date = '2025-02-23'

# Download stock data
data = yf.download(tickers, start=start_date, end=end_date)

# Check if 'Adj Close' exists, otherwise use 'Close'
if 'Adj Close' in data.columns:
    prices = data['Adj Close']
else:
    prices = data['Close']

# Ensure data is clean
prices = prices.dropna()

# Function to perform ADF test and print results
def adf_test(series, name):
    result = adfuller(series, autolag='AIC')
    print(f'\nADF Test for {name}:')
    print(f'ADF Statistic: {result[0]:.4f}')
    print(f'p-value: {result[1]:.4f}')
    print(f'Lags Used: {result[2]}')
    print(f'Number of Observations: {result[3]}')
    print('Critical Values:')
    for key, value in result[4].items():
        print(f'   {key}: {value:.4f}')
    if result[1] < 0.05:
        print('Conclusion: Stationary (reject null hypothesis of unit root)')
    else:
        print('Conclusion: Non-stationary (fail to reject null hypothesis of unit root)')
    return result

# Function to check for random walk
def random_walk_check(series, name):
    print(f'\nRandom Walk Check for {name}:')
    # ADF on original series
    adf_orig = adf_test(series, f'{name} Original')
    # First difference
    diff_series = series.diff().dropna()
    adf_diff = adf_test(diff_series, f'{name} First Difference')

    if adf_orig[1] >= 0.05 and adf_diff[1] < 0.05:
        print(f'Conclusion: {name} behaves like a random walk (non-stationary original, stationary after differencing)')
    else:
        print(f'Conclusion: {name} does not clearly behave like a random walk')

# Function to calculate moving averages
def calculate_moving_averages(series, name):
    ma9 = series.rolling(window=9).mean()
    ma30 = series.rolling(window=30).mean()
    return ma9, ma30

# Function to plot prices and moving averages
def plot_stock_data(series, ma9, ma30, name):
    plt.figure(figsize=(12, 6))
    plt.plot(series, label='Adjusted Close', color='blue')
    plt.plot(ma9, label='9-day MA', color='orange')
    plt.plot(ma30, label='30-day MA', color='green')
    plt.title(f'{name} Stock Price with Moving Averages')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.grid()
    plt.show()

# Perform analyses for each stock
for ticker in tickers:
    print(f'\n=== Analysis for {ticker} ===')

    # Unit Root Test
    adf_test(prices[ticker], f'{ticker} Adjusted Close')

    # Random Walk Check
    random_walk_check(prices[ticker], ticker)

    # Calculate Moving Averages
    ma9, ma30 = calculate_moving_averages(prices[ticker], ticker)

    # Plot
    plot_stock_data(prices[ticker], ma9, ma30, ticker)

# Cointegration Analysis
print('\n=== Pairwise Cointegration Analysis (Engle-Granger) ===')
pairs = [('AMZN', 'GOOGL'), ('AMZN', 'JPM'), ('AMZN', 'NVDA'),
         ('GOOGL', 'JPM'), ('GOOGL', 'NVDA'), ('JPM', 'NVDA')]

for pair in pairs:
    stock1, stock2 = pair
    score, pvalue, _ = coint(prices[stock1], prices[stock2])
    print(f'\nCointegration Test: {stock1} vs {stock2}')
    print(f'Test Statistic: {score:.4f}')
    print(f'p-value: {pvalue:.4f}')
    if pvalue < 0.05:
        print(f'Conclusion: Evidence of cointegration (reject null of no cointegration)')
        print(f'Implication: {stock1} and {stock2} may have a long-term equilibrium relationship')
    else:
        print(f'Conclusion: No evidence of cointegration (fail to reject null)')
        print(f'Implication: {stock1} and {stock2} do not share a stable long-term relationship')

# Johansen Cointegration Test (for all stocks together)
print('\n=== Johansen Cointegration Test (All Stocks) ===')
johansen_result = coint_johansen(prices, det_order=0, k_ar_diff=1)
print('Eigenvalues:', johansen_result.eig)
print('\nTrace Statistic vs Critical Values:')
for i in range(len(johansen_result.lr1)):
    print(f'Rank={i}: Trace Stat = {johansen_result.lr1[i]:.4f}, Crit (90%) = {johansen_result.cvt[i, 0]:.4f}, '
          f'Crit (95%) = {johansen_result.cvt[i, 1]:.4f}, Crit (99%) = {johansen_result.cvt[i, 2]:.4f}')
    if johansen_result.lr1[i] > johansen_result.cvt[i, 1]:
        print(f'   => Evidence of cointegration at rank {i} (95% confidence)')
    else:
        print(f'   => No evidence of cointegration at rank {i}')